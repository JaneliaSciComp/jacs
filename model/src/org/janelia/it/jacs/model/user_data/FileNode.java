/*
 * Copyright (c) 2010-2011, J. Craig Venter Institute, Inc.
 *
 * This file is part of JCVI VICS.
 *
 * JCVI VICS is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the Artistic License 2.0.  For
 * details, see the full text of the license in the file LICENSE.txt.  No
 * other rights are granted.  Any and all third party software rights to
 * remain with the original developer.
 *
 * JCVI VICS is distributed in the hope that it will be useful in
 * bioinformatics applications, but it is provided "AS IS" and WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTIES including but not limited to
 * implied warranties of merchantability or fitness for any particular
 * purpose.  For details, see the full text of the license in the file
 * LICENSE.txt.
 *
 * You should have received a copy of the Artistic License 2.0 along with
 * JCVI VICS.  If not, the license can be obtained from
 * "http://www.perlfoundation.org/artistic_license_2_0."
 */

package org.janelia.it.jacs.model.user_data;
// Generated Aug 17, 2006 3:17:24 PM by Hibernate Tools 3.2.0.beta6a

import com.google.gwt.user.client.rpc.IsSerializable;
import org.janelia.it.jacs.model.common.SystemConfigurationProperties;
import org.janelia.it.jacs.model.tasks.Task;

import java.io.File;
import java.io.Serializable;

/**
 * FileNode generated by hbm2java
 */
public abstract class FileNode extends Node implements Serializable, IsSerializable {
    // Non-persistant fields
    public transient static final String CENTRAL_DIR_PROP = "FileStore.CentralDir";

    // Persistant Fields
    // The pathOverride is intended to override the directory used - instead of the default filestore locations
    // It should always end with the file.separator
    private String pathOverride;
    private Boolean isReplicated = Boolean.FALSE;

    // Constructors

    /**
     * default constructor
     */
    public FileNode() {
    }

    /**
     * old full constructor
     *
     * @param owner               - person who owns the node
     * @param task                - task which created this node
     * @param name                - name of the node
     * @param description         - description of the node
     * @param visibility          - visibility of the node to others
     * @param relativeSessionPath - name of the work session this node belongs to
     * @param dataType            - tag for the node
     */
    public FileNode(String owner, Task task, String name, String description, String visibility, String dataType,
                    String relativeSessionPath) {
        super(owner, task, name, description, visibility, dataType, relativeSessionPath);
    }

    // Property accessors
    protected String getFilestorePath() {
        return SystemConfigurationProperties.getString(CENTRAL_DIR_PROP);
    }


    /**
     * This method resolves where things live.  Logic follows this order:
     * 1) Is there an explicit path? (pathOverride)
     * 2) FileStore.CentralDir/Owner/relativeSessionDirectoryPath/NodeSubDirectory/NodeObjectId
     *
     * @return returns the path to the directory
     */
    public String getDirectoryPath() {
        // Check for the path override
        if (null != getPathOverride() && !"".equals(getPathOverride())) {
            return getPathOverride();
        }

        // Get the filestore root path
        String tmpRoot = getFilestorePath();

        // Check for the owner
        String owner = getOwner();
        if (owner == null) {
            throw new IllegalArgumentException("userLogin must not be null");
        }

        // Get the dir of the work session, if any
        String tmpWorkSessionName = getRelativeSessionPath();

        // Get the subdirectory for the node type
        String tmpSubDir = getSubDirectory();

        // Get the specific instance id directory of the node
        String simplePath = getObjectId().toString();
        String treePath = getTreePathForId(getObjectId());

        StringBuffer tmpFinalPath = new StringBuffer();
        tmpFinalPath.append(tmpRoot).append(File.separator);
        tmpFinalPath.append(owner).append(File.separator);
        if (null != tmpWorkSessionName && !"".equals(tmpWorkSessionName)) {
            tmpFinalPath.append(tmpWorkSessionName).append(File.separator);
        }
        if (null != tmpSubDir && !"".equals(tmpSubDir)) {
            tmpFinalPath.append(tmpSubDir).append(File.separator);
        }
        String simpleFinalPath = tmpFinalPath + simplePath;
        String treeFinalPath = tmpFinalPath + treePath;

        File simpleFinalFile = new File(simpleFinalPath);

        if (simpleFinalFile.exists()) {
            return simpleFinalPath;
        } else {
            return treeFinalPath;
        }
    }

    public String getFilePath(String filename) {
        // Check for the path override
        if (null != getPathOverride() && !"".equals(getPathOverride())) {
            return getPathOverride();
        }
        return getDirectoryPath() + File.separator + filename;
    }

    public abstract String getSubDirectory();

    public String getPath() {
        return null;
    }

    public abstract String getFilePathByTag(String tag);

    public String getPathOverride() {
        return pathOverride;
    }

    public void setPathOverride(String pathOverride) {
        this.pathOverride = pathOverride;
    }

    // Methods to help set if the file node is replicated elsewhere (TeraGrid?) (Temporary solution)
    public Boolean getIsReplicated() {
        return null != isReplicated && isReplicated;
    }

    public void setIsReplicated(Boolean replicated) {
        isReplicated = replicated;
    }

    // For directory abcdefghijklmnop, this returns:
    //
    //  klm/nop/abcdefghijklmnop
    //
    public static String getTreePathForId(Long id) {
        String idAsString=id.toString();
        int length=idAsString.length();
        if (length<7) {
            return null;
        }
        String firstThree=idAsString.substring(length-6, length-3);
        String secondThree=idAsString.substring(length-3);
        return firstThree + File.separator + secondThree + File.separator + idAsString;
    }


}


