/*
 * Copyright (c) 2010-2011, J. Craig Venter Institute, Inc.
 *
 * This file is part of JCVI VICS.
 *
 * JCVI VICS is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the Artistic License 2.0.  For
 * details, see the full text of the license in the file LICENSE.txt.  No
 * other rights are granted.  Any and all third party software rights to
 * remain with the original developer.
 *
 * JCVI VICS is distributed in the hope that it will be useful in
 * bioinformatics applications, but it is provided "AS IS" and WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTIES including but not limited to
 * implied warranties of merchantability or fitness for any particular
 * purpose.  For details, see the full text of the license in the file
 * LICENSE.txt.
 *
 * You should have received a copy of the Artistic License 2.0 along with
 * JCVI VICS.  If not, the license can be obtained from
 * "http://www.perlfoundation.org/artistic_license_2_0."
 */

package org.janelia.it.jacs.model.user_data;

import com.google.gwt.user.client.rpc.IsSerializable;
import org.janelia.it.jacs.model.tasks.Task;
import org.janelia.it.jacs.model.user_data.prefs.UserPreference;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * User generated by hbm2java
 */
public class User implements java.io.Serializable, IsSerializable // NOT IsSerializable
{
    // Fields
    public static final String SYSTEM_USER_LOGIN = "system";

    private Long userId;
    private String userLogin = "";
    private String fullName = "";
    private String email = "";

    transient private boolean administrator = false;

    private Set<Node> nodes = new HashSet<Node>(0);
    private Set<Task> tasks = new HashSet<Task>(0);
    private Map<String, UserPreference> preferenceMap = new HashMap<String, UserPreference>(0);
    private Map<String, Map<String, UserPreference>> categoryMap = new HashMap<String, Map<String, UserPreference>>(0);

    // Constructors

    /**
     * default constructor
     */
    public User() {
    }

    /**
     * full constructor
     *
     * @param userLogin - username
     * @param name      - user's full name
     * @param nodes     - nodes for this user
     * @param tasks     - tasks associated with this user
     */
    public User(String userLogin, String name, Set<Node> nodes, Set<Task> tasks) {
        this.userLogin = userLogin;
        this.fullName = name;
        this.nodes = nodes;
        this.tasks = tasks;
    }


    // Property accessors
    public String getUserLogin() {
        return this.userLogin;
    }

    public void setUserLogin(String userLogin) {
        this.userLogin = userLogin;
    }

    public String getFullName() {
        return fullName;
    }

    public void setFullName(String fullName) {
        this.fullName = fullName;
    }

    public Set<Node> getNodes() {
        return this.nodes;
    }

    public void setNodes(Set<Node> nodes) {
        this.nodes = nodes;
    }

    public Set<Task> getTasks() {
        return this.tasks;
    }

    public void setTasks(Set<Task> tasks) {
        this.tasks = tasks;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String toString() {
        return "User{" +
                "userLogin='" + userLogin + '\'' +
                ", fullName='" + fullName + '\'' +
                ", email='" + email + '\'' +
                '}';
    }

    public Long getUserId() {
        return userId;
    }

    public void setUserId(Long userId) {
        this.userId = userId;
    }

    public void addNode(Node newNode) {
        if (null != newNode) {
            nodes.add(newNode);
            newNode.setOwner(this.getUserLogin());
        }
    }

    private Map getCategoryMap() {
        return categoryMap;
    }

    /**
     * Creates a map of preferences by category name
     */
    private synchronized void buildCategoryMap() {
        for (String s : preferenceMap.keySet()) {
            addPreferenceToCategoryMap(preferenceMap.get(s));
        }
    }

    private synchronized void addPreferenceToCategoryMap(UserPreference pref) {
        Map<String, UserPreference> catPrefs = getCategoryPreferences(pref.getCategory()); // creates new Map if not found
        catPrefs.put(pref.getName(), pref);
        categoryMap.put(pref.getCategory(), catPrefs);
    }

    public synchronized Map<String, UserPreference> getCategoryPreferences(String category) {
        if (getCategoryMap().containsKey(category))
            return categoryMap.get(category);
        else
            return new HashMap<String, UserPreference>();
    }

    public synchronized void setPreferenceMap(Map<String, UserPreference> preferenceMap) {
        this.preferenceMap = preferenceMap;
        buildCategoryMap();
    }

    public Map<String, UserPreference> getPreferenceMap() {
        return preferenceMap;
    }

    /**
     * Returns the preference with the supplied category or name, or null if no such preference exists
     *
     * @param category - preference category
     * @param name     - preference name looked for
     * @return - the matching UserPreference object
     */
    public synchronized UserPreference getPreference(String category, String name) {
        return preferenceMap.get(getPrefKey(category, name));
    }

    private String getPrefKey(String category, String name) {
        return category + ":" + name;
    }

    public String getPreferenceValue(String category, String name) {
        return getPreference(category, name).getValue();
    }

    /**
     * Updates the preference in the User cache and database.
     *
     * @param pref desired user preference to update
     */
    public synchronized void setPreference(UserPreference pref) {
        preferenceMap.put(getPrefKey(pref.getCategory(), pref.getName()), pref);  // Hibernate will update database
        addPreferenceToCategoryMap(pref); // Add/update the preference in the appropriate category
    }

    public boolean isAdministrator() {
        return administrator;
    }

    public void setAdministrator(boolean administrator) {
        this.administrator = administrator;
    }


}


