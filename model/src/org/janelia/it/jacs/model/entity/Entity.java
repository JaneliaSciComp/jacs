package org.janelia.it.jacs.model.entity;
// Generated May 26, 2011 10:42:23 AM by Hibernate Tools 3.2.1.GA


import java.util.*;

import javax.xml.bind.annotation.*;

import org.janelia.it.jacs.model.user_data.User;

import com.google.gwt.user.client.rpc.IsSerializable;

/**
 * Entity generated by hbm2java
 */
@XmlAccessorType(XmlAccessType.FIELD)
public class Entity  implements java.io.Serializable, IsSerializable {
	
	@XmlAttribute
    private Long id;
	
	@XmlElement
    private String name;
    
	@XmlElement
	private User user;

	@XmlElement
    private EntityStatus entityStatus;

	@XmlElement
    private EntityType entityType;
	
	@XmlTransient
    private Date creationDate;

	@XmlTransient
    private Date updatedDate;
    
    @XmlElement(name="entityData")
    @XmlElementWrapper(name="entityDataSet")
    private Set<EntityData> entityData = new HashSet<EntityData>(0);

    public Entity() {
    }
	
    public Entity(Long id) {
        this.id = id;
    }
    public Entity(Long id, String name, User user, EntityStatus entityStatus, EntityType entityType, Date creationDate,
                  Date updatedDate, Set<EntityData> entityData) {
       this.id = id;
       this.name = name;
       this.user = user;
       this.entityStatus = entityStatus;
       this.entityType = entityType;
       this.creationDate = creationDate;
       this.updatedDate = updatedDate;
       this.entityData = entityData;
    }
   
    public Long getId() {
        return this.id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    public User getUser() {
        return this.user;
    }
    
    public void setUser(User user) {
        this.user = user;
    }
    public EntityStatus getEntityStatus() {
        return this.entityStatus;
    }
    
    public void setEntityStatus(EntityStatus entityStatus) {
        this.entityStatus = entityStatus;
    }
    public EntityType getEntityType() {
        return this.entityType;
    }
    
    public void setEntityType(EntityType entityType) {
        this.entityType = entityType;
    }
    public Date getCreationDate() {
        return this.creationDate;
    }
    
    public void setCreationDate(Date creationDate) {
        this.creationDate = creationDate;
    }
    public Date getUpdatedDate() {
        return this.updatedDate;
    }
    
    public void setUpdatedDate(Date updatedDate) {
        this.updatedDate = updatedDate;
    }
    public Set<EntityData> getEntityData() {
        return this.entityData;
    }
    
    public void setEntityData(Set<EntityData> entityData) {
        this.entityData = entityData;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    // Utility methods

    public EntityAttribute getAttributeByName(String name) {
        Set<EntityAttribute> attributeSet = entityType.getAttributes();
        for (EntityAttribute ea : attributeSet) {
            if (ea.getName().equals(name)) {
                return ea;
            }
        }
        return null;
    }

    public boolean addAttributeAsTag(String attributeName) {
        Set<EntityData> data=this.getEntityData();
        EntityAttribute attribute = this.getAttributeByName(attributeName);
        if (attribute==null) {
            return false;
        } else {
            EntityData tag = new EntityData();
            tag.setParentEntity(this);
            tag.setEntityAttribute(attribute);
            tag.setUser(user);
            Date createDate = new Date();
            tag.setCreationDate(createDate);
            tag.setUpdatedDate(createDate);
            tag.setValue(attribute.getName());
            data.add(tag);
        }
        return true;
    }

	/**
	 * Returns the set of EntityData objects with the given attribute name.
	 */
	public EntityData getEntityDataByAttributeName(String attributeName) {
		Set<EntityData> matchingData = new HashSet<EntityData>();
		for (EntityData ed : entityData) {
			if (ed.getEntityAttribute().getName().matches(attributeName)) {
				matchingData.add(ed);
			}
		}
		if (matchingData.size() == 1) {
			EntityData ed = matchingData.iterator().next();
			return ed;
		}
		if (matchingData.size() > 1) {
			System.out.println("Warning: expected single EntityData for "+attributeName+" in Entity#"+getId()+" but got "+matchingData.size());
		}
		return null;
	}

	/**
	 * Returns the value of the given attribute, if it exists and there is only one.
	 */
	public String getValueByAttributeName(String attributeName) {
		EntityData ed = getEntityDataByAttributeName(attributeName);
		if (ed == null) return null;
		return ed.getValue();
	}

    // This is the sister method of the above 'getValueByAttributeName'
    // which does the inverse.

    public boolean setValueByAttributeName(String attributeName, String value) {
        Set<EntityData> matchingData=new HashSet<EntityData>();
        for (EntityData ed : entityData) {
            if (ed.getEntityAttribute().getName().matches(attributeName)) {
                matchingData.add(ed);
            }
        }
        if (matchingData.size()==0) {
            // Ok, we will add this
            EntityAttribute attribute=getAttributeByName(attributeName);
            if (attribute==null) {
                throw new IllegalArgumentException("Entity "+getId()+" with type "+getEntityType().getName()+" does not have attribute: "+attributeName);
            }
            EntityData ed=new EntityData();
            ed.setParentEntity(this);
            ed.setEntityAttribute(attribute);
            ed.setValue(value);
            ed.setUser(user);
            this.entityData.add(ed);
            return true;
        } else if (matchingData.size()==1) {
            // Update the value of the existing entry
            EntityData ed=matchingData.iterator().next();
            ed.setValue(value);
            return true;
        }
        // More than one EntityData matching the attribute - do nothing
        return false;
    }

    // This returns the EntityData so it can be persisted
    public EntityData addChildEntity(Entity entity) {
    	return addChildEntity(entity, EntityConstants.ATTRIBUTE_ENTITY);
    }

    // This returns the EntityData so it can be persisted
    public EntityData addChildEntity(Entity entity, String attributeName) {
        EntityData ed=new EntityData();
        ed.setParentEntity(this);
        ed.setChildEntity(entity);
        ed.setUser(user);
        Date createDate = new Date();
        ed.setCreationDate(createDate);
        ed.setUpdatedDate(createDate);
        EntityAttribute attribute=getAttributeByName(attributeName);
        if (attribute==null) throw new IllegalStateException("Entity type "+entityType.getName()+" does not support attributes of type "+attributeName);
        ed.setEntityAttribute(attribute);
        this.entityData.add(ed);
        return ed;
    }

	/**
	 * Returns the an ordered list of EntityData objects with the given attribute name.
	 */
	public List<EntityData> getList(String attributeName) {
		List<EntityData> matchingData = new ArrayList<EntityData>();
		for (EntityData ed : getOrderedEntityData()) {
			if (ed.getEntityAttribute().getName().matches(attributeName)) {
				matchingData.add(ed);
			}
		}
		return matchingData;
	}
	
	public Integer getMaxOrderIndex() {
		int max = 0;
		for(EntityData ed : entityData) {
			if (ed.getOrderIndex() != null && ed.getOrderIndex() > max) {
				max = ed.getOrderIndex();
			}
		}
		return max;
	}
	
    public List<EntityData> getOrderedEntityData() {
    	List<EntityData> orderedData = new ArrayList<EntityData>(getEntityData());
    	Collections.sort(orderedData, new Comparator<EntityData>() {
			@Override
			public int compare(EntityData o1, EntityData o2) {
				if (o1.getOrderIndex() == null) {
					if (o2.getOrderIndex() == null) {
						return o1.getId().compareTo(o2.getId());
					}
					return -1;
				}
				else if (o2.getOrderIndex() == null) {
					return 1;
				}
				return o1.getOrderIndex().compareTo(o2.getOrderIndex());
			}
    		
		});
    	return orderedData;
    }

    /**
     * Get all the descendants (including self) which are of a certain type. Depends on the subtree of entities 
     * "below" this one being loaded.
     *
     * @param entity
     * @param typeName
     * @return
     */
    public List<Entity> getDescendantsOfType(String typeName) {

        List<Entity> items = new ArrayList<Entity>();
        if (typeName==null || typeName.equals(getEntityType().getName())) {
            items.add(this);
        }

        for (EntityData entityData : getOrderedEntityData()) {
            Entity child = entityData.getChildEntity();
            if (child != null) {
                items.addAll(child.getDescendantsOfType(typeName));
            }
        }

        return items;
    }

    public List<Entity> getChildrenOfType(String typeName) {

        List<Entity> items = new ArrayList<Entity>();
        for (EntityData entityData : getOrderedEntityData()) {
            Entity child = entityData.getChildEntity();
            if (typeName==null || typeName.equals(getEntityType().getName())) {
                items.add(child);
            }
        }

        return items;
    }

    public List<Entity> getOrderedChildren() {
    	List<Entity> children = new ArrayList<Entity>();
    	for(EntityData ed : getOrderedEntityData()) {
        	if (ed.getChildEntity() != null) children.add(ed.getChildEntity());
    	}
    	return children;
    }

	public boolean hasChildren() {
    	for(EntityData ed : entityData) {
        	if (ed.getChildEntity() != null) {
        		return true;
        	}
    	}
    	return false;
	}
    
    public Set<Entity> getChildren() {
    	Set<Entity> children = new HashSet<Entity>();
    	for(EntityData ed : entityData) {
        	if (ed.getChildEntity() != null) children.add(ed.getChildEntity());
    	}
    	return children;
    }
    
    @Override
    public String toString() {
        return getName();
    }
}


