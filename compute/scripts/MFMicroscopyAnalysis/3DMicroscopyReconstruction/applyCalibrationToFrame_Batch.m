%{
INPUT:

imFilename: filename (with complete path) of the 2D image containing the raw data raw data

outFilename: filename (with complete path) where the 3D stack consisting of 9 slices will be saved

calibrationFile: mat file generated by the routine calibrationBeads.m containing the needed transformations


Transformations are applied as follows:

transformPerSlice{kk}.b * XY * transformPerSlice{kk}.T + transformPerSlice{kk}.c

where XY are the image coordinates


OUTPUT:

stack: 3D stack obtained from 2D raw data and saved at outFilename
%}

function applyCalibrationToFrame(calibrationFile)

%read image 
%imFilename='D:/Analysis/3D Gaussian 08_03/H2B SNAP 07 26/SNAP TMR 016 flip.tif'
disp('Please select the folder which ONLY contains the raw image stack which is needed to be processed!!')
folder_name = uigetdir
%folder_name = 'C:\Users\labadmin\Desktop\Analysis\Output\Reconstruction\PSF beads3 07-26 cut by 07-26 mat'
files=dir(fullfile(folder_name,'*.tif'));
h = waitbar(0,'Start...');
for i=1:length(files)

imFilename=[folder_name '\' files(i).name];
outFolder= folder_name
mkdir(outFolder,files(i).name(1:end-4))
outFilename=[outFolder,'\',files(i).name(1:end-4),'\',files(i).name(1:end-4)]

%read calibration parameters
load(calibrationFile,'transformPerSlice','cornerPerSlice');



%%
%apply transformations to each image

info=imfinfo(imFilename);
numFrames=length(info);

%-3 is to make sure it fits and they all have the same size
stack=zeros(cornerPerSlice(1,3)-cornerPerSlice(1,1)-3,cornerPerSlice(1,4)-cornerPerSlice(1,2)-3,9,'uint16');
mask=true(size(stack,1),size(stack,2));

for ff=1:numFrames
    im=imread(imFilename,'Index',ff);
    for kk=1:9
        patch=im(cornerPerSlice(kk,1):cornerPerSlice(kk,1)+size(stack,1)-1,cornerPerSlice(kk,2):cornerPerSlice(kk,2)+size(stack,2)-1);
        
        [X Y]=meshgrid(0:size(patch,1)-1,0:size(patch,2)-1);%to match peak coordinates from calibrationBEads.m routine
        X=X';
        Y=Y';
        %apply transformation to meshgrid
        %aux=transformPerSlice{kk}.b * [X(:) Y(:)] * transformPerSlice{kk}.T + repmat(transformPerSlice{kk}.c(1,:),[size(patch,1)*size(patch,2) 1]);
        aux= ([X(:) Y(:)]-repmat(transformPerSlice{kk}.c(1,:),[size(patch,1)*size(patch,2) 1])) * transformPerSlice{kk}.T'/transformPerSlice{kk}.b;
        
        XI=reshape(aux(:,1),size(X));
        YI=reshape(aux(:,2),size(Y));
        %interpolate images
        stack(:,:,kk) = uint16(interp2(Y,X,double(patch),YI,XI,'*cubic'));
        
        if(ff==1)
            %find maximum region without zero-border filling
            maskPos=find(XI<cornerPerSlice(1,2) | YI<cornerPerSlice(1,1) | XI>size(patch,1) | YI>size(patch,2));
            mask(maskPos)=false;
        end
    
    end
    
    if(ff==1)
        %find cropping area to make sure we do not include zero-filling after
        %aligning the images
        border=1;
        while(sum(mask(border:end-border+1,border:end-border+1)==false)>0)
            border=border+1;
        end
    end
    
    outF=[outFilename num2str(ff-1,'%.4d') '.tif'];
    imwrite(stack(border:end-border+1,border:end-border+1, 1), outF, 'Compression', 'none', 'WriteMode', 'overwrite');
    for kk=2:size(stack,3)
        imwrite(stack(border:end-border+1,border:end-border+1, kk), outF, 'Compression', 'none', 'WriteMode', 'append');
    end
    
    
    end
%%
    perc=ff/numFrames*100;
    waitbar(perc/100,h,sprintf('%3.2g%% along...',perc))
disp(['Cropped ' num2str(border) ' pixels to avoid zero-filling after alignment'])
end
perc=100;
waitbar(perc,h,sprintf('Finish! Reconstructed images in the same folder',perc))
end