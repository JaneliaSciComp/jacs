%{
INPUT:

imFilename: filename (with complete path) of the 2D image containing the raw data raw data

outFilename: filename (with complete path) where the 3D stack consisting of 9 slices will be saved

calibrationFile: mat file generated by the routine calibrationBeads.m containing the needed transformations


Transformations are applied as follows:

transformPerSlice{kk}.b * XY * transformPerSlice{kk}.T + transformPerSlice{kk}.c

where XY are the image coordinates


OUTPUT:

stack: 3D stack obtained from 2D raw data and saved at outFilename
%}

function applyCalibrationToFrame(PathName,FileName,calibrationFile, externalBorderValue)
%%
%read image 
%h = waitbar(0,'Initializing waitbar...');

imFilename=[PathName,FileName];
mkdir(PathName,'Reconstructed');
outFilename=[PathName,'/Reconstructed/',FileName(1:end-4)];%write without tif extension

%read calibration parameters
load(calibrationFile,'transformPerSlice','cornerPerSlice');



%%
%apply transformations to each image

info=imfinfo(imFilename);
numFrames=length(info);

%-3 is to make sure it fits and they all have the same size
stack=zeros(cornerPerSlice(1,3)-cornerPerSlice(1,1)-3,cornerPerSlice(1,4)-cornerPerSlice(1,2)-3,9,'uint16');
mask=true(size(stack,1),size(stack,2));
assignin('base','numFrames',numFrames);

for ff=1:numFrames
    im=imread(imFilename,'Index',ff);
    for kk=1:9
        patch=im(cornerPerSlice(kk,1):cornerPerSlice(kk,1)+size(stack,1)-1,cornerPerSlice(kk,2):cornerPerSlice(kk,2)+size(stack,2)-1);
        
        [X Y]=meshgrid(0:size(patch,1)-1,0:size(patch,2)-1);%to match peak coordinates from calibrationBEads.m routine
        X=X';
        Y=Y';
        %apply transformation to meshgrid
        %aux=transformPerSlice{kk}.b * [X(:) Y(:)] * transformPerSlice{kk}.T + repmat(transformPerSlice{kk}.c(1,:),[size(patch,1)*size(patch,2) 1]);
        aux= ([X(:) Y(:)]-repmat(transformPerSlice{kk}.c(1,:),[size(patch,1)*size(patch,2) 1])) * transformPerSlice{kk}.T'/transformPerSlice{kk}.b;
        
        XI=reshape(aux(:,1),size(X));
        YI=reshape(aux(:,2),size(Y));
        %interpolate images
        stack(:,:,kk) = uint16(interp2(Y,X,double(patch),YI,XI,'*cubic'));
        
        if(ff==1)
            %find maximum region without zero-border filling
            maskPos=find(XI<cornerPerSlice(1,2) | YI<cornerPerSlice(1,1) | XI>size(patch,1) | YI>size(patch,2));
            mask(maskPos)=false;
        end
        
    end
%    perc=75;
    %waitbar(perc/100,h,sprintf('%d%% along...',perc))
    if(ff==1)
        %find cropping area to make sure we do not include zero-filling after
        %aligning the images
    if (isempty(externalBorderValue))
        border=1;
        while(sum(mask(border:end-border+1,border:end-border+1)==false)>0)
            border=border+1;
        end
    else
        outStr=sprintf('Using external border value %s\n',externalBorderValue);
        disp(outStr)
        border=str2double(externalBorderValue);
    end

    end
    %% One could fix one border value.
%if(ff==1)

%    choice = questdlg('Do you want to specify the border value?', ...
%	'Border value', ...
%	'Yes','No','No');

%switch choice
%    case 'Yes'
%    border=input('Please specify the border value:');
%    case 'No'
%    disp('Do nothing')
%end
%end
    %%
    outF=[outFilename '_' num2str(ff-1,'%.4d') '.tif'];
    imwrite(stack(border:end-border+1,border:end-border+1, 1), outF, 'Compression', 'none', 'WriteMode', 'overwrite');
    for kk=2:size(stack,3)
        imwrite(stack(border:end-border+1,border:end-border+1, kk), outF, 'Compression', 'none', 'WriteMode', 'append');
    end
end
%%
%perc=100;
%waitbar(perc/100,h,sprintf('Finish. Images in the ''Reconstructed'' subfolder',perc))
disp(['Cropped ' num2str(border) ' pixels to avoid zero-filling after alignment'])
