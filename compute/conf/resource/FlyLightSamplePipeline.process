 <!-- 
      Fully process a Sample in the database. Potentially this can include merging LSMs, stitching and blending them, 
      aligning, and running analysis algorithms such as neuron separation. 
 -->
 <process name="FlyLight Sample Pipeline" processor="queue/samplePipelineLauncher" startEvent="pending">
	<sequence name="Main">

        <input name="SAMPLE_ENTITY_ID"/>
        <input name="PIPELINE_NAME"/>
        <input name="MERGE_ALGORITHMS"/>
        <input name="STITCH_ALGORITHMS"/>
        <input name="ALIGNMENT_ALGORITHMS"/>
        <input name="ALIGNMENT_ALGORITHM_PARAMS"/>
        <input name="ALIGNMENT_ALGORITHM_RESULT_NAMES"/>
        <input name="SKIP_ALIGNMENT_TILE_FILTER"/>
        <input name="ANALYSIS_ALGORITHMS"/>
        <input name="PIPELINE_PROCESS"/>
        <input name="CHANNEL_DYE_SPEC"/>
        <input name="OUTPUT_CHANNEL_ORDER"/>
        <input name="REUSE_PROCESSING"/>
        <input name="REUSE_ALIGNMENT"/>
        
        <!-- Import variables from the task if any were not passed in as input parameters above -->
        <operation name="Import Variables" processor="org.janelia.it.jacs.compute.service.common.InitVariablesFromTaskService">
            <input name="OVERRIDE" value="false"/>
            <input name="SAMPLE_ENTITY_ID"/>
            <input name="PIPELINE_NAME"/>
            <input name="MERGE_ALGORITHMS"/>
            <input name="STITCH_ALGORITHMS"/>
            <input name="ALIGNMENT_ALGORITHMS"/>
            <input name="ALIGNMENT_ALGORITHM_PARAMS"/>
            <input name="ALIGNMENT_ALGORITHM_RESULT_NAMES"/>
            <input name="ANALYSIS_ALGORITHMS"/>
            <input name="PIPELINE_PROCESS"/>
            <input name="REUSE_PROCESSING"/>
            <input name="REUSE_ALIGNMENT"/>
            <input name="TASK_PARAMETER_MAP">
                <entry key="sample entity id" value="SAMPLE_ENTITY_ID"/>
                <entry key="pipeline name" value="PIPELINE_NAME"/>
                <entry key="merge algorithms" value="MERGE_ALGORITHMS"/>
                <entry key="stitch algorithms" value="STITCH_ALGORITHMS"/>
                <entry key="alignment algorithms" value="ALIGNMENT_ALGORITHMS"/>
                <entry key="alignment algorithm parameters" value="ALIGNMENT_ALGORITHM_PARAMS"/>
                <entry key="alignment algorithm result names" value="ALIGNMENT_ALGORITHM_RESULT_NAMES"/>
                <entry key="analysis algorithms" value="ANALYSIS_ALGORITHMS"/>
                <entry key="pipeline process" value="PIPELINE_PROCESS"/>
                <entry key="reuse processing" value="REUSE_PROCESSING"/>
                <entry key="reuse alignment" value="REUSE_ALIGNMENT"/>
            </input>
            <output name="SAMPLE_ENTITY_ID"/>
            <output name="PIPELINE_NAME"/>
            <output name="MERGE_ALGORITHMS"/>
            <output name="STITCH_ALGORITHMS"/>
            <output name="ALIGNMENT_ALGORITHMS"/>
            <output name="ALIGNMENT_ALGORITHM_PARAMS"/>
            <output name="ALIGNMENT_ALGORITHM_RESULT_NAMES"/>
            <output name="ANALYSIS_ALGORITHMS"/>
            <output name="PIPELINE_PROCESS"/>
            <output name="REUSE_PROCESSING"/>
            <output name="REUSE_ALIGNMENT"/>
        </operation>

        <!-- Set our status -->
        <operation name="Set Status" processor="org.janelia.it.jacs.compute.service.entity.sample.SetSampleStatusService">
            <input name="ENTITY_ID" value="$V{SAMPLE_ENTITY_ID}"/>
            <input name="STATUS" value="Processing"/>
        </operation>
        
        <!-- By default, skip alignment if any lamina tiles are present. -->
        <operation name="Init Variables" processor="org.janelia.it.jacs.compute.service.common.InitVariablesService">
            <input name="SKIP_ALIGNMENT_TILE_FILTER"/>
            <input name="OVERRIDE" value="false"/>
            <input name="PROCESS_VARIABLE_MAP">
                <entry key="SKIP_ALIGNMENT_TILE_FILTER" value="(?i).*lamina.*"/>
            </input>
            <output name="SKIP_ALIGNMENT_TILE_FILTER"/>
        </operation>

        <!-- Create the pipeline run entity -->
        <operation name="Create Pipeline Run Entity" processor="org.janelia.it.jacs.compute.service.entity.sample.CreatePipelineRunEntityService">
            <input name="SAMPLE_ENTITY_ID"/>
            <input name="PIPELINE_NAME"/>
            <input name="PIPELINE_PROCESS"/>
            <output name="PIPELINE_RUN_ENTITY_ID"/>
        </operation>
        
        <!-- Read from the Entity model and export the data into parameters that will be used by the subsequent services -->
        <operation name="Get Sample Attributes" processor="org.janelia.it.jacs.compute.service.entity.sample.InitSampleAttributesService">
            <input name="SAMPLE_ENTITY_ID"/>
            <output name="SAMPLE_AREAS"/>
            <output name="SAMPLE_AREA"/>
        </operation>
		
        <sequence forEach="SAMPLE_AREA">
            
            <!-- Decide which types of processing will be run -->
            <operation name="Choose Sample Area Processing Steps" processor="org.janelia.it.jacs.compute.service.entity.sample.ChooseSampleAreaPipelineStepsService">
                <input name="SAMPLE_ENTITY_ID"/>
                <input name="SAMPLE_AREA"/>
                <input name="MERGE_ALGORITHMS"/>
                <input name="STITCH_ALGORITHMS"/>
                <input name="ANALYSIS_ALGORITHMS"/>
                <output name="RUN_PROCESSING"/>
                <output name="RUN_MERGE"/>
                <output name="RUN_STITCH"/>
                <output name="RUN_ANALYSIS"/>
                <output name="MERGE_ALGORITHM"/>
                <output name="STITCH_ALGORITHM"/>
                <output name="ANALYSIS_ALGORITHM"/>
            </operation>
            
    		<sequence if="REUSE_PROCESSING=true">
        		
                <!-- Reuse sample processing from previous pipeline run -->
                <operation name="Reuse Sample Processing Entity" processor="org.janelia.it.jacs.compute.service.entity.sample.ReuseSampleProcessingResultService">
                    <input name="SAMPLE_ENTITY_ID"/>
                    <input name="PIPELINE_RUN_ENTITY_ID"/>
                    <input name="SAMPLE_AREA"/>
                    <output name="STITCHED_FILENAME"/>
                    <output name="RUN_PROCESSING"/>
                    <output name="RESULT_ENTITY_ID"/>
                </operation>
            
                <!-- Was there a sample processing result that could be reused? -->
                <sequence if="RUN_PROCESSING=false">
                
                    <!-- Set the result for this sample area -->
                    <operation name="Set Sample Processing Results" processor="org.janelia.it.jacs.compute.service.entity.sample.SetSampleProcessingAreaService">
                        <input name="SAMPLE_AREA"/>
                        <input name="RESULT_ENTITY_ID"/>
                    </operation>
                    
                    <!-- Register MIP images -->
                    <operation name="Register images" processor="org.janelia.it.jacs.compute.service.entity.sample.ResultImageRegistrationService">
                        <input name="RESULT_ENTITY_ID"/>
                        <input name="DEFAULT_IMAGE_FILENAME" value="$V{STITCHED_FILENAME}"/>
                        <input name="PIPELINE_RUN_ENTITY_ID"/>
                    </operation>
                    
                </sequence>
                
            </sequence>
            
            <sequence if="RUN_PROCESSING=true" name="Sample processing" startEvent="running">
            
        	    <!-- Create a sample result node, with nested result nodes for all the pipeline steps -->
        	    <operation name="Create Sample Result Nodes" processor="org.janelia.it.jacs.compute.service.entity.CreateSampleResultFileNodeService">
        	        <output name="RESULT_FILE_NODE"/>
        	        <output name="RESULT_FILE_NODE_ID"/>
        	        <output name="SAMPLE_RESULT_FILE_NODE"/>
        	        <output name="METADATA_RESULT_FILE_NODE"/>
        	        <output name="MERGE_RESULT_FILE_NODE"/>
        	        <output name="GROUP_RESULT_FILE_NODE"/>
        	        <output name="STITCH_RESULT_FILE_NODE"/>
        	        <output name="MIPS_RESULT_FILE_NODE"/>
        	    </operation>
        	    
        	    <!-- Read from the Entity model and export the data into parameters that will be used by the subsequent services -->
        	    <sequence name="Wait Async" waitForAsync="true">
    			    <operation name="Init Processing Parameters" processor="org.janelia.it.jacs.compute.service.entity.InitSampleProcessingParametersService">
    			        <input name="MERGE_RESULT_FILE_NODE"/>
    			        <input name="STITCH_RESULT_FILE_NODE"/>
    					<input name="SAMPLE_ENTITY_ID"/>
                        <input name="SAMPLE_AREA"/>
    					<input name="RUN_STITCH"/>
    					<output name="BULK_MERGE_PARAMETERS"/>
    					<output name="STITCHED_FILENAME"/>
    					<output name="STACK_FILENAMES"/>
    					<output name="SAMPLE_PROCESSING_RESULTS_NAME"/>
    				</operation>
        	    </sequence>
        	    
    		    <!-- Create a result node for this group -->
    		    <operation name="Create Temp Result Node" processor="org.janelia.it.jacs.compute.service.entity.CreateNamedResultFileNodeService">
    			    <input name="NAME" value="Temp"/>
    			    <input name="OUTPUT_VAR_NAME" value="LSM_FILE_NODE"/>
    		        <output name="LSM_FILE_NODE"/>
    		        <output name="LSM_FILE_NODE_ID"/>
    		    </operation>
    		    
    		    <!-- Get the LSM file paths and update the bulk merge parameters to use the copied files -->
		        <operation name="Get LSM file paths" processor="org.janelia.it.jacs.compute.service.entity.sample.GetLsmFilePathsService">
                    <input name="RESULT_FILE_NODE" value="$V{LSM_FILE_NODE}"/>
					<input name="BULK_MERGE_PARAMETERS"/>
                    <output name="BULK_MERGE_PARAMETERS"/>
                    <output name="LSM_SOURCE_FILE_PATHS"/>
                    <output name="LSM_TARGET_FILE_PATHS"/>
		        </operation>
    		
                <!-- Copy the files from archive -->
                <sequence name="Wait Async" waitForAsync="true">
                    <operation name="Copy LSMs" processor="queue/gridSubmitAndWait">
                        <input name="iservice" value="org.janelia.it.jacs.compute.service.utility.ArchiveGridService"/>
                        <input name="RESULT_FILE_NODE" value="$V{LSM_FILE_NODE}"/>
                        <input name="SOURCE_FILE_PATHS" value="$V{LSM_SOURCE_FILE_PATHS}"/>
                        <input name="TARGET_FILE_PATHS" value="$V{LSM_TARGET_FILE_PATHS}"/>
                    </operation>
                </sequence>
                
        	    <!-- Asynchronously create the metadata describing the input LSM files -->
                <sequence name="Create Lsm Metadata Files" waitForAsync="true">
        	        <operation name="Create Lsm Metadata Files" processor="queue/gridSubmitAndWait">
        	            <input name="iservice" value="org.janelia.it.jacs.compute.service.entity.CreateLsmMetadataFilesService"/>
        		        <input name="SAMPLE_ENTITY_ID"/>
                        <input name="BULK_MERGE_PARAMETERS"/>
        		        <input name="RESULT_FILE_NODE" value="$V{METADATA_RESULT_FILE_NODE}"/>
        	    		<input name="OUTPUT_FILE_NODE" value="$V{METADATA_RESULT_FILE_NODE}"/>
        	        </operation>
                </sequence>
                
                <!-- Run merging? -->
            	<sequence if="RUN_MERGE=true">
        		     
        		    <!-- Despite this loop, currently this pipeline supports only a single merge algorithm at time. -->
                    <sequence forEach="MERGE_ALGORITHM">
                    
            		    <!-- Merge all the LSM pairs in parallel -->
            	        <sequence name="Merge LSM Pairs" waitForAsync="true">
            		        <operation name="Merge LSM Pairs" processor="queue/gridSubmitAndWait">
            		            <input name="iservice" value="org.janelia.it.jacs.compute.service.vaa3d.Vaa3DBulkMergeService"/>
            		    		<input name="RESULT_FILE_NODE" value="$V{MERGE_RESULT_FILE_NODE}"/>
            					<input name="BULK_MERGE_PARAMETERS"/>
            					<input name="MERGE_ALGORITHM"/>
            		        </operation>
            	        </sequence>
            	        
                    </sequence>
        		
                </sequence>
                
                <!-- Rearrange the channels on each tile so that they are in the correct output format -->
                <sequence name="Convert to sample image" waitForAsync="true">
                    <operation name="Convert to sample image" processor="queue/gridSubmitAndWait">
                        <input name="iservice" value="org.janelia.it.jacs.compute.service.vaa3d.Vaa3DConvertToSampleImageService"/>
                        <input name="RESULT_FILE_NODE" value="$V{MERGE_RESULT_FILE_NODE}"/>
                        <input name="BULK_MERGE_PARAMETERS"/>
                        <input name="MERGE_ALGORITHM"/>
                        <input name="METADATA_RESULT_FILE_NODE"/>
                        <input name="RUN_MERGE"/>
                        <input name="SAMPLE_ENTITY_ID"/>
                        <input name="SAMPLE_AREA"/>
                        <input name="CHANNEL_DYE_SPEC"/>
                        <input name="OUTPUT_CHANNEL_ORDER"/>
                        <output name="CHANNEL_SPEC"/>
                        <output name="SIGNAL_CHANNELS"/>
                        <output name="REFERENCE_CHANNEL"/>
                        <output name="LSM_CHANNEL_MAPPING"/>
                    </operation>
                </sequence>
        	            	
    		    <!-- We're done with the LSMs -->
    		    <operation name="Remove Temp Result Nodes" processor="org.janelia.it.jacs.compute.service.entity.TrashFileNodeService">
    		        <input name="FILE_NODE_ID" value="$V{LSM_FILE_NODE_ID}"/>
    		    </operation>
    		   
            	<!-- Run stitcher? -->
            	<sequence if="RUN_STITCH=true" name="Tile stitching">
        	
        		    <!-- Determine tile groupings and pick the largest group for processing -->
        	        <sequence name="Determine Stitch Grouping" waitForAsync="true">
        		        <operation name="Stitch Grouping" processor="queue/gridSubmitAndWait">
        		            <input name="iservice" value="org.janelia.it.jacs.compute.service.vaa3d.Vaa3DStitchGroupingService"/>
        		    		<input name="RESULT_FILE_NODE" value="$V{GROUP_RESULT_FILE_NODE}"/>
        		    		<input name="INPUT_FILE_NODE" value="$V{MERGE_RESULT_FILE_NODE}"/>
        					<input name="BULK_MERGE_PARAMETERS"/>
        					<input name="REFERENCE_CHANNEL"/>
        					<input name="SAMPLE_AREA"/>
        					<output name="BULK_MERGE_PARAMETERS"/>
        					<output name="RUN_STITCH"/>
        		        </operation>
        	        </sequence>
	        	        
                	<!-- Run the stitcher, unless if the grouper decides we don't need to -->
	            	<sequence if="RUN_STITCH=true">
	            	
	        		    <!-- Stitch the merged files into a single result -->
	        	        <sequence name="Stitch and Blend" waitForAsync="true">
	        		        <operation name="Stitch and Blend" processor="queue/gridSubmitAndWait">
	        		            <input name="iservice" value="org.janelia.it.jacs.compute.service.vaa3d.Vaa3DStitchAndBlendService"/>
	        		    		<input name="RESULT_FILE_NODE" value="$V{STITCH_RESULT_FILE_NODE}"/>
	        		    		<input name="INPUT_FILE_NODE" value="$V{GROUP_RESULT_FILE_NODE}"/>
	        					<input name="BULK_MERGE_PARAMETERS"/>
	        					<input name="REFERENCE_CHANNEL"/>
	        					<input name="STITCHED_FILENAME"/>
	        		        </operation>
	        	        </sequence>
	        	        
	                </sequence>
	                
                </sequence>
                
                <!-- Else, or if the grouper determined we don't need to run the stitcher -->
            	<sequence if="RUN_STITCH=false">
        	    
        		    <!-- If we're not stitching then the single tile is considered the stitched file -->
        		    <operation name="Create Parameters" processor="org.janelia.it.jacs.compute.service.entity.InitSingleMergeParametersService">
        				<input name="BULK_MERGE_PARAMETERS"/>
        				<output name="STITCHED_FILENAME"/>
        			</operation>
        				
                </sequence>
                    
        	    <!-- Generate MIP for the stitched file -->
                <sequence name="Generate sample MIPs" waitForAsync="true">
        	        <operation name="Generate MIPs" processor="queue/gridSubmitAndWait">
        	            <input name="iservice" value="org.janelia.it.jacs.compute.service.neuronSeparator.MIPGenerationService"/>
        				<input name="RESULT_FILE_NODE" value="$V{MIPS_RESULT_FILE_NODE}"/>
        				<input name="INPUT_FILENAMES" value="$V{STACK_FILENAMES}"/>
        				<input name="SIGNAL_CHANNELS"/>
        				<input name="REFERENCE_CHANNEL"/>
        	        </operation>
                </sequence>
                
        	    <!-- Clean up merged files, unless there is one tile that is being used as the stitched image -->
        		<operation name="Remove merged files" processor="org.janelia.it.jacs.compute.service.entity.sample.CleanUpMergedTilesService">
        			<input name="BULK_MERGE_PARAMETERS"/>
        			<input name="STITCHED_FILENAME"/>
        	    </operation>
        	    
        	    <!-- Load the sample analysis results into the database -->
        		<operation name="Discover Sample Processing Results" processor="org.janelia.it.jacs.compute.service.fileDiscovery.SampleProcessingResultsDiscoveryService">
        			<input name="ROOT_FILE_NODE" value="$V{SAMPLE_RESULT_FILE_NODE}"/>
        			<input name="ROOT_ENTITY_ID" value="$V{PIPELINE_RUN_ENTITY_ID}"/>
        			<input name="RESULT_ENTITY_TYPE" value="Sample Processing Result"/>
        			<input name="RESULT_ENTITY_NAME" value="$V{SAMPLE_PROCESSING_RESULTS_NAME}"/>
        			<input name="SAMPLE_ENTITY_ID"/>
        			<input name="CHANNEL_SPEC"/>
        			<input name="SAMPLE_AREA"/>
        			<input name="LSM_CHANNEL_MAPPING"/>
        			<input name="STITCHED_FILENAME"/>
        			<output name="RESULT_ENTITY_ID"/>
        	    </operation>
            	    
        	    <!-- Register MIP images -->
        		<operation name="Register images" processor="org.janelia.it.jacs.compute.service.entity.sample.ResultImageRegistrationService">
        			<input name="PIPELINE_RUN_ENTITY_ID"/>
        			<input name="RESULT_ENTITY_ID"/>
        			<input name="DEFAULT_IMAGE_FILENAME" value="$V{STITCHED_FILENAME}"/>
        			<output name="DEFAULT_IMAGE_ID"/>
        	    </operation>
    		
                <!-- Set the result for this sample area -->
                <operation name="Set Sample Processing Results" processor="org.janelia.it.jacs.compute.service.entity.sample.SetSampleProcessingAreaService">
                    <input name="SAMPLE_AREA"/>
                    <input name="RESULT_ENTITY_ID"/>
                </operation>
                
        		<!-- Run analyses on unaligned results, if there are signal channels to analyze -->
                <sequence if="SIGNAL_CHANNELS is not empty">
                
                    <sequence if="RUN_ANALYSIS=true">
                        <sequence forEach="ANALYSIS_ALGORITHM">
                                
                            <!-- Decide what pipeline to run -->
                            <operation name="Get Parameters" processor="org.janelia.it.jacs.compute.service.entity.sample.InitAnalysisParametersService">
                                <input name="ANALYSIS_ALGORITHM"/>
                                <input name="RESULT_ENTITY_ID"/>
                                <input name="SAMPLE_ENTITY_ID"/>
                                <output name="OUTPUT_FILENAME"/>
                                <output name="ANALYSIS_PIPELINE_NAME"/>
                                <output name="OPTICAL_RESOLUTION"/>
                                <output name="PIXEL_RESOLUTION"/>
                                <output name="OBJECTIVE"/>
                                <output name="ALIGNED_CONSOLIDATED_LABEL_FILEPATH"/>
                            </operation>
                            
                            <!-- Run neuron separation on prealigned data -->
                            <include process="FlyLightSeparationPipeline" name="Unaligned neuron separation" startEvent="running">
                                <input name="ROOT_ENTITY_ID" value="$V{RESULT_ENTITY_ID}"/>
                                <input name="SAMPLE_ENTITY_ID"/>
                                <input name="INPUT_FILENAME" value="$V{OUTPUT_FILENAME}"/>
                                <input name="INPUT_IMAGE_ID" value="$V{DEFAULT_IMAGE_ID}"/>
                                <input name="SIGNAL_CHANNELS"/>
                                <input name="REFERENCE_CHANNEL"/>
                                <input name="OPTICAL_RESOLUTION"/>
                                <input name="PIXEL_RESOLUTION"/>
                                <input name="OBJECTIVE"/>
                                <input name="ALIGNED_CONSOLIDATED_LABEL_FILEPATH"/>
                            </include>
                            
                        </sequence>
                    </sequence>
                    
                </sequence>
                
            </sequence>
                
        </sequence>
            
        <!-- Decide which types of processing will be run -->
        <operation name="Choose Next Steps" processor="org.janelia.it.jacs.compute.service.entity.sample.ChoosePostSampleProcessingStepsService">
            <input name="SAMPLE_ENTITY_ID"/>
            <input name="SAMPLE_AREAS"/>
            <input name="ALIGNMENT_ALGORITHMS"/>
            <input name="ALIGNMENT_ALGORITHM_PARAMS"/>
            <input name="ALIGNMENT_ALGORITHM_RESULT_NAMES"/>
            <input name="SKIP_ALIGNMENT_TILE_FILTER"/>
            <input name="ANALYSIS_ALGORITHMS"/>
            <output name="RUN_ALIGNMENT"/>
            <output name="RUN_ANALYSIS"/>
            <output name="PARAMETERIZED_ALIGNMENT_ALGORITHM"/>
            <output name="ANALYSIS_ALGORITHM"/>
        </operation>
        
        <sequence if="RUN_ALIGNMENT=true">
            <sequence forEach="PARAMETERIZED_ALIGNMENT_ALGORITHM">
                <sequence>
            
                    <!-- Run brain alignment on prealigned data -->
                    <include name="Alignment" process="FlyLightAlignmentPipeline" startEvent="running">
                        <input name="PIPELINE_RUN_ENTITY_ID"/>
                        <input name="SAMPLE_ENTITY_ID"/>
                        <input name="SAMPLE_AREAS"/>
                        <input name="PARAMETERIZED_ALIGNMENT_ALGORITHM"/>
                        <input name="RUN_ANALYSIS"/>
                        <input name="RUN_ALIGNMENT"/>
                        <input name="ANALYSIS_ALGORITHM"/>
                        <input name="REUSE_ALIGNMENT"/>
                    </include>
                    
                </sequence>
            </sequence>
        </sequence>
        
		<!-- Compress all v3draw files to v3dpbd, and generate accompanying h5j files -->
        <include name="Sample compression" process="PostPipeline_SampleCompression">
            <input name="ROOT_ENTITY_ID" value="$V{SAMPLE_ENTITY_ID}"/>
            <input name="COMPRESSION_TYPE" value="Visually Lossless and PBD"/>
        </include>
        
        <!-- Move all generated files to archive -->
        <include name="Move sample to archive" process="SyncSampleToArchive">
            <input name="SAMPLE_ENTITY_ID"/>
        </include>
        
        <!-- Set our status -->
        <operation name="Set Status" processor="org.janelia.it.jacs.compute.service.entity.sample.SetSampleStatusService">
            <input name="ENTITY_ID" value="$V{SAMPLE_ENTITY_ID}"/>
            <input name="STATUS" value="Complete"/>
        </operation>
        
	    <exceptionHandler>
	    
            <!-- Set our status -->
            <operation name="Set Status" processor="org.janelia.it.jacs.compute.service.entity.sample.SetSampleStatusService">
                <input name="ENTITY_ID" value="$V{SAMPLE_ENTITY_ID}"/>
                <input name="STATUS" value="Error"/>
            </operation>
            
		    <!-- Log the exception into the Pipeline Run -->
			<operation name="Handle exceptions" processor="org.janelia.it.jacs.compute.service.entity.sample.CreateErrorEntityService">
				<input name="ROOT_ENTITY_ID" value="$V{PIPELINE_RUN_ENTITY_ID}"/>
				<input name="RESULT_FILE_NODE"/>
				<input name="PROCESSING_EXCEPTION"/>
		    </operation>
		
	    </exceptionHandler>
	    
    </sequence>
    
</process>