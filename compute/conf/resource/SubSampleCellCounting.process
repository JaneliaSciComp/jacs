<!--
     Fully process a Sample in the database. Potentially this can include merging LSMs, stitching and blending them,
     aligning, and running analysis algorithms such as neuron separation.
     
     TODO: This pipeline is completely broken, due to many changes in the services supporting FlyLightSamplePipeline, which this was copy and pasted from. 
     This needs to be rewritten as an analysis step for the normal pipeline. 
-->
<process name="Cell Counting Sample Pipeline" processor="queue/samplePipelineLauncher" startEvent="pending">
    <sequence name="Main">
    
        <input name="SAMPLE_ENTITY_ID"/>
        <input name="OBJECTIVE"/>
        <input name="PIPELINE_NAME"/>
        <input name="PIPELINE_PROCESS"/>
        <input name="RUN_CELL_COUNTING"/>
        <input name="CHANNEL_DYE_SPEC"/>
        <input name="OUTPUT_CHANNEL_ORDER"/>

        <!-- Create the pipeline run entity -->
        <operation name="Create Pipeline Run Entity" processor="org.janelia.it.jacs.compute.service.domain.sample.CreatePipelineRunEntityService">
            <input name="SAMPLE_ENTITY_ID"/>
            <input name="PIPELINE_NAME"/>
            <input name="PIPELINE_PROCESS"/>
            <output name="PIPELINE_RUN_ENTITY_ID"/>
        </operation>

        <!-- Read from the Entity model and export the data into parameters that will be used by the subsequent services -->
        <operation name="Get Sample Attributes" processor="org.janelia.it.jacs.compute.service.domain.sample.InitSampleAttributesService">
            <input name="SAMPLE_ENTITY_ID"/>
            <output name="SIGNAL_CHANNELS"/>
            <output name="REFERENCE_CHANNEL"/>
            <output name="SAMPLE_AREA"/>
        </operation>

        <sequence forEach="SAMPLE_AREA">
            <!-- Decide which types of processing will be run -->
            <operation name="Choose Sample Area Processing Steps" processor="org.janelia.it.jacs.compute.service.domain.sample.ChooseSampleAreaPipelineStepsService">
                <input name="SAMPLE_ENTITY_ID"/>
                <input name="SAMPLE_AREA"/>
                <input name="MERGE_ALGORITHMS"/>
                <input name="STITCH_ALGORITHMS"/>
                <input name="ANALYSIS_ALGORITHMS"/>
                <output name="RUN_PROCESSING"/>
                <output name="RUN_MERGE"/>
                <output name="RUN_STITCH"/>
                <output name="RUN_ANALYSIS"/>
                <output name="MERGE_ALGORITHM"/>
                <output name="STITCH_ALGORITHM"/>
                <output name="ANALYSIS_ALGORITHM"/>
            </operation>

            <!-- Create a sample result node, with nested result nodes for all the pipeline steps -->
            <operation name="Create Sample Result Nodes" processor="org.janelia.it.jacs.compute.service.domain.node.CreateSampleResultFileNodeService">
                <output name="RESULT_FILE_NODE"/>
                <output name="RESULT_FILE_NODE_ID"/>
                <output name="SAMPLE_RESULT_FILE_NODE"/>
                <output name="METADATA_RESULT_FILE_NODE"/>
                <output name="MERGE_RESULT_FILE_NODE"/>
                <output name="GROUP_RESULT_FILE_NODE"/>
                <output name="STITCH_RESULT_FILE_NODE"/>
            </operation>

            <!-- Read from the Entity model and export the data into parameters that will be used by the subsequent services -->
            <sequence name="Wait Async" waitForAsync="true">
                <sequence name="Limit Archive Access" processor="queue/archiveAccess">
                    <operation name="Init Processing Parameters" processor="org.janelia.it.jacs.compute.service.domain.sample.InitSampleProcessingParametersService">
                        <input name="SAMPLE_RESULT_FILE_NODE"/>
                        <input name="MERGE_RESULT_FILE_NODE"/>
                        <input name="STITCH_RESULT_FILE_NODE"/>
                        <input name="SAMPLE_ENTITY_ID"/>
                        <output name="BULK_MERGE_PARAMETERS"/>
                        <output name="STITCHED_FILENAME"/>
                        <output name="STACK_FILENAMES"/>
                        <output name="COPY_FROM_ARCHIVE"/>
                    </operation>
                </sequence>
            </sequence>

            <sequence if="COPY_FROM_ARCHIVE=true">
                <!-- Create a result node for this group -->
                <operation name="Create Group Result Nodes" processor="org.janelia.it.jacs.compute.service.domain.node.CreateNamedResultFileNodeService">
                    <input name="NAME" value="Temp"/>
                    <input name="OUTPUT_VAR_NAME" value="LSM_FILE_NODE"/>
                    <output name="LSM_FILE_NODE"/>
                    <output name="LSM_FILE_NODE_ID"/>
                </operation>

                <!-- Copy the files, and update the paths in the merge parameters -->
                <sequence name="Wait Async" waitForAsync="true">
                    <sequence name="Limit Archive Access" processor="queue/archiveAccess">
                        <operation name="Copy Lsms" processor="org.janelia.it.jacs.compute.service.entity.sample.CopyLsmsFromArchiveService">
                            <input name="RESULT_FILE_NODE" value="$V{LSM_FILE_NODE}"/>
                            <input name="BULK_MERGE_PARAMETERS"/>
                            <output name="BULK_MERGE_PARAMETERS"/>
                        </operation>
                    </sequence>
                </sequence>

            </sequence>

            <!-- Asynchronously create the metadata describing the input LSM files -->
            <sequence name="Create Lsm Metadata Files" waitForAsync="true">
                <operation name="Create Lsm Metadata Files" processor="queue/gridSubmitAndWait">
                    <input name="iservice" value="org.janelia.it.jacs.compute.service.domain.sample.CreateLsmMetadataFilesService"/>
                    <input name="BULK_MERGE_PARAMETERS"/>
                    <input name="RESULT_FILE_NODE" value="$V{METADATA_RESULT_FILE_NODE}"/>
                    <input name="OUTPUT_FILE_NODE" value="$V{METADATA_RESULT_FILE_NODE}"/>
                </operation>
            </sequence>

            <!-- Convert the image to the sample image format, leave the channels alone -->
            <sequence name="Convert to sample image" waitForAsync="true">
                <operation name="Convert to sample image" processor="queue/gridSubmitAndWait">
                    <input name="iservice" value="org.janelia.it.jacs.compute.service.vaa3d.Vaa3DConvertToSampleImageService"/>
                    <input name="RESULT_FILE_NODE" value="$V{MERGE_RESULT_FILE_NODE}"/>
                    <input name="SAMPLE_ENTITY_ID"/>
                    <input name="OBJECTIVE"/>
                    <input name="METADATA_RESULT_FILE_NODE"/>
                    <input name="BULK_MERGE_PARAMETERS"/>
                    <input name="SAMPLE_AREA"/>
                    <input name="CHANNEL_DYE_SPEC"/>
                    <input name="OUTPUT_CHANNEL_ORDER"/>
                    <output name="CHANNEL_SPEC"/>
                    <output name="SIGNAL_CHANNELS"/>
                    <output name="REFERENCE_CHANNEL"/>
                </operation>
            </sequence>

            <sequence if="COPY_FROM_ARCHIVE=true">
                <!-- We're done with the LSMs -->
                <operation name="Remove Temp Result Nodes" processor="org.janelia.it.jacs.compute.service.domain.node.TrashFileNodeService">
                    <input name="FILE_NODE_ID" value="$V{LSM_FILE_NODE_ID}"/>
                </operation>
            </sequence>

            <sequence>
                <!-- If we're not stitching then the single tile is considered the stitched file -->
                <operation name="Create Parameters" processor="org.janelia.it.jacs.compute.service.domain.sample.InitMultiMergeParametersService">
                    <input name="BULK_MERGE_PARAMETERS"/>
                    <input name="STACK_FILENAMES"/>
                    <output name="TILE_FILENAMES"/>
                    <output name="STACK_FILENAME"/>
                </operation>
            </sequence>

            <sequence name="Generate sample MIPs" waitForAsync="true">
                <operation name="Generate MIPs" processor="queue/gridSubmitAndWait">
                    <input name="iservice" value="org.janelia.it.jacs.compute.service.neuronSeparator.MIPGenerationService"/>
                    <input name="RESULT_FILE_NODE" value="$V{STITCH_RESULT_FILE_NODE}"/>
                    <input name="INPUT_FILENAMES" value="$V{STACK_FILENAMES}"/>
                    <input name="SIGNAL_CHANNELS"/>
                    <input name="REFERENCE_CHANNEL"/>
                </operation>
            </sequence>

            <!-- Load the sample analysis results into the database -->
            <operation name="Discover Sample Processing Results" processor="org.janelia.it.jacs.compute.service.fileDiscovery.SupportingFilesDiscoveryService">
                <input name="ROOT_FILE_NODE" value="$V{SAMPLE_RESULT_FILE_NODE}"/>
                <input name="ROOT_ENTITY_ID" value="$V{PIPELINE_RUN_ENTITY_ID}"/>
                <input name="RESULT_ENTITY_TYPE" value="Sample Processing Result"/>
                <input name="RESULT_ENTITY_NAME" value="Sample Processing"/>
                <output name="RESULT_ENTITY_ID"/>
            </operation>

            <!-- Run analyses on unaligned results -->
            <!-- Decide what pipeline to run -->
            <sequence if="RUN_CELL_COUNTING=yes">
                <sequence forEach="ANALYSIS_ALGORITHM">
                    <operation name="Get Parameters" processor="org.janelia.it.jacs.compute.service.domain.sample.InitAnalysisParametersService">
                        <input name="ANALYSIS_ALGORITHM"/>
                        <input name="RESULT_ENTITY_ID"/>
                        <output name="OUTPUT_FILENAME"/>
                        <output name="ANALYSIS_PIPELINE_NAME"/>
                    </operation>

                    <sequence forEach="TILE_FILENAMES">
                        <operation name="Create Cell Counting Result Nodes" processor="org.janelia.it.jacs.compute.service.domain.node.CreateNamedResultFileNodeService">
                            <input name="NAME" value="CellCounting"/>
                            <input name="OUTPUT_VAR_NAME" value="CELL_COUNTING_FILE_NODE"/>
                            <output name="CELL_COUNTING_FILE_NODE"/>
                            <output name="CELL_COUNTING_FILE_NODE_ID"/>
                        </operation>
                        <sequence name="Cell Counting Grid" waitForAsync="true">
                            <operation name="Cell Counting" processor="queue/gridSubmitAndWait">
                                <input name="iservice" value="org.janelia.it.jacs.compute.service.vaa3d.Vaa3dCellCountingService"/>
                                <input name="INPUT_FILE" value="$V{TILE_FILENAMES}"/>
                                <input name="RESULT_FILE_NODE_ID" value="$V{CELL_COUNTING_FILE_NODE_ID}"/>
                                <input name="RESULT_FILE_NODE" value="$V{CELL_COUNTING_FILE_NODE}"/>
                                <input name="SIGNAL_CHANNELS"/>
                                <input name="REFERENCE_CHANNEL"/>
                                <output name="RESULT_FILE_NODE_ID"/>
                                <output name="RESULT_FILE_NODE"/>
                                <output name="ARCHIVE_FILE_PATHS"/>
                                <output name="CELL_COUNTING_FILE_NODE"/>
                                <output name="CELL_COUNTING_FILE_NODE_ID"/>
                                <output name="CELL_COUNTING_MIP_FILES"/>
                                <output name="RAW_RESULT_FILE"/>
                            </operation>
                        </sequence>
                        <sequence name="Generate sample MIPs" waitForAsync="true">
                            <operation name="Generate MIPs" processor="queue/gridSubmitAndWait">
                                <input name="iservice" value="org.janelia.it.jacs.compute.service.neuronSeparator.MIPGenerationService"/>
                                <input name="RESULT_FILE_NODE" value="$V{CELL_COUNTING_FILE_NODE}"/>
                                <input name="INPUT_FILENAMES" value="$V{CELL_COUNTING_MIP_FILES}"/>
                                <input name="SIGNAL_CHANNELS" value="0 1 2"/>
                                <input name="REFERENCE_CHANNEL" value=""/>
                            </operation>
                        </sequence>
                        <operation name="Discover Sample Processing Results" processor="org.janelia.it.jacs.compute.service.fileDiscovery.CellCountingResultsDiscoveryService">
                            <input name="ROOT_FILE_NODE" value="$V{CELL_COUNTING_FILE_NODE}"/>
                            <input name="ROOT_ENTITY_ID" value="$V{PIPELINE_RUN_ENTITY_ID}"/>
                            <input name="RESULT_ENTITY_TYPE" value="Cell Counting Result"/>
                            <input name="RESULT_ENTITY_NAME" value="Cell Counting Result"/>
                            <output name="RESULT_ENTITY_ID"/>
                        </operation>
                    </sequence>
                </sequence>
            </sequence>
        </sequence>

        <!-- Compress all the v3draw files we created  -->
        <include name="Compress raw files" process="SampleDataCompression">
            <input name="ROOT_ENTITY_ID" value="$V{SAMPLE_ENTITY_ID}"/>
        </include> 
        
        <!-- Compress all the v3draw files we created  -->
        <exceptionHandler>
            <!-- Log the exception into the Pipeline Run -->
            <operation name="Handle exceptions" processor="org.janelia.it.jacs.compute.service.domain.sample.CreateErrorEntityService">
                <input name="ROOT_ENTITY_ID" value="$V{PIPELINE_RUN_ENTITY_ID}"/>
                <input name="PROCESSING_EXCEPTION"/>
            </operation>
        </exceptionHandler>

    </sequence>
</process>