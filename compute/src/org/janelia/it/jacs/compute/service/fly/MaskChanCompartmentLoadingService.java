package org.janelia.it.jacs.compute.service.fly;

import org.janelia.it.jacs.compute.api.ComputeException;
import org.janelia.it.jacs.compute.service.entity.AbstractEntityService;
import org.janelia.it.jacs.compute.service.fileDiscovery.FileDiscoveryHelper;
import org.janelia.it.jacs.model.common.SystemConfigurationProperties;
import org.janelia.it.jacs.model.entity.Entity;
import org.janelia.it.jacs.model.entity.EntityConstants;
import org.janelia.it.jacs.model.entity.EntityType;
import org.janelia.it.jacs.shared.annotation.PatternAnnotationDataManager;
import org.janelia.it.jacs.shared.utils.EntityUtils;
import org.janelia.it.jacs.shared.utils.StringUtils;

import java.io.*;
import java.util.*;

/**
 * This service loads screen scores from *.arnimScoreOutput files generated by Sean's Perl scripts, and organizes the 
 * screen samples into intensity and distribution score folders. 
 *
 * @author <a href="mailto:rokickik@janelia.hhmi.org">Konrad Rokicki</a>
 */
public class MaskChanCompartmentLoadingService extends AbstractEntityService {
	
	private static final boolean DEBUG = false;
	
    private static final String FOLDER_PARAM = "TOP_LEVEL_FOLDER_NAME";
    private static final String INPATH_PARAM = "MASK_CHAN_PATH";
    private static final String OPTICAL_RES_PARAM = "OPTICAL_RESOLUTION";
    private static final String PIXEL_RES_PARAM = "PIXEL_RESOLUTION";

    private static final String FILESTORE_ROOT_PATH = SystemConfigurationProperties.getString("FileStore.CentralDir");
    private static final String COMPARTMENT_NAMES_FILE = FILESTORE_ROOT_PATH+File.separator+"/MaskResources/Compartment/maskNameIndex.txt";
    private static final String COMPARTMENT_FILE_PREFIX = "compartment_";

    private static final String DEFAULT_ALIGNMENT_SPACE = "Unified 20x Alignment Space";
    private static final String DEFAULT_OPTICAL_RESOLUTION = "0.62x0.62x0.62";
    private static final String DEFAULT_PIXEL_RESOLUTION = "1024x512x218";

    protected Date createDate;
	protected FileDiscoveryHelper helper;
        
    protected SortedSet<String> loaded = new TreeSet<String>();

    /**
     * See the MaskChanCompartmentsLoadingPipeline.process:
     *
     * 	    <operation name="Import Variables" processor="org.janelia.it.jacs.compute.service.common.InitVariablesFromTaskService">
     *      <input name="TASK_PARAMETER_1" value="mask chan file path"/>
     *      <input name="PROCESS_VARIABLE_1" value="MASK_CHAN_PATH"/>
     *      <input name="TASK_PARAMETER_2" value="top level folder name"/>
     *      <input name="PROCESS_VARIABLE_2" value="TOP_LEVEL_FOLDER_NAME"/>
     *      <input name="TASK_PARAMETER_3" value="optical resolution"/>
     *      <input name="PROCESS_VARIABLE_3" value="OPTICAL_RESOLUTION"/>
     *      <input name="TASK_PARAMETER_4" value="pixel resolution"/>
     *      <input name="PROCESS_VARIABLE_4" value="PIXEL_RESOLUTION"/>
     *      <output name="MASK_CHAN_PATH"/>
     *      <output name="TOP_LEVEL_FOLDER_NAME"/>
     *      <output name="OPTICAL_RESOLUTION"/>
     *      <output name="PIXEL_RESOLUTION"/>
     *      </operation>
     *
     * @throws Exception
     */
    @Override
    public void execute() throws Exception {

        createDate = new Date();
        helper = new FileDiscoveryHelper(entityBean, computeBean, ownerKey, logger);
        
        String inputFSFolder = (String)processData.getItem(INPATH_PARAM);

    	if (inputFSFolder == null) {
    		throw new IllegalArgumentException(INPATH_PARAM + " may not be null");
    	}

        String jacsFolder = (String)processData.getItem(FOLDER_PARAM);
    	if (jacsFolder == null) {
    		throw new IllegalArgumentException(FOLDER_PARAM + " may not be null");
    	}

        String opticalResolution = (String)processData.getItem(OPTICAL_RES_PARAM);
        if ( opticalResolution == null ) {
            opticalResolution = DEFAULT_OPTICAL_RESOLUTION;
        }

        String pixelResolution = (String)processData.getItem(PIXEL_RES_PARAM);
        if ( pixelResolution == null ) {
            pixelResolution = DEFAULT_PIXEL_RESOLUTION;
        }
    	
        // Check input path: has files of correct type?  If so, get them into a convenient form.
        Map<String,MaskChannel> folderContents = readInputFolderContents(inputFSFolder);

    	// Create top level folder (or obtained the named empty one).
    	Entity topLevelFolder = populateChildren(createOrVerifyRootEntity(jacsFolder, ownerKey, createDate, true, false));
    	
    	if (!topLevelFolder.getChildren().isEmpty()) {
    		throw new IllegalStateException(
                    "Cannot reuse existing top level with name " + jacsFolder + " folder, id="+topLevelFolder
            );
    	}

        // Compartments belong to a compartment set that has characteristics of all contents.
        String compartmentSetName = EntityConstants.TYPE_COMPARTMENT_SET + " " + DEFAULT_ALIGNMENT_SPACE + " " + opticalResolution + " " + pixelResolution;
        Entity compartmentSetEntity = createCompartmentSetEntity( EntityConstants.TYPE_COMPARTMENT_SET, compartmentSetName, opticalResolution, pixelResolution );

        // Add this set as an entity-child of the folder.
        helper.addToParent( topLevelFolder, compartmentSetEntity, topLevelFolder.getMaxOrderIndex()+1, EntityConstants.ATTRIBUTE_ENTITY );

        // Get the mask/name index contents.
        Map<Integer,CompartmentDescriptor> indexToCompartment = parseCompartmentsDescriptorFile();

        // Order them, and map back to the order number.
        Set<CompartmentDescriptor> orderedCompartments = new TreeSet<CompartmentDescriptor>();
        for ( Integer key: indexToCompartment.keySet() ) {
            CompartmentDescriptor descriptor = indexToCompartment.get( key );
            orderedCompartments.add(descriptor);
        }

        Map<CompartmentDescriptor,Integer> descriptorToOrder = new TreeMap<CompartmentDescriptor,Integer>();
        int ord = 0;
        for ( CompartmentDescriptor nextDescriptor: orderedCompartments ) {
            descriptorToOrder.put( nextDescriptor, ord++ );
        }

        // Process each Mask/Channel combination.  Indexes start at 0, so bump by one.
    	for ( String key: folderContents.keySet() ) {
            logger.info("Saving compartment " + key);
            MaskChannel maskChannel = folderContents.get( key );

            // Create the compartment and add it to the set.
            int index = indexFromName( key );
            CompartmentDescriptor compartmentDescriptor = indexToCompartment.get(index);
            Entity compartment = createCompartmentEntity(EntityConstants.TYPE_COMPARTMENT, index, compartmentDescriptor);
            helper.addToParent(
                    compartmentSetEntity,
                    compartment,
                    descriptorToOrder.get( compartmentDescriptor ),
                    EntityConstants.ATTRIBUTE_ENTITY
            );

            // Create the mask and channel and add them to the compartment.
            createAndAddMaskChanEntities( compartment, maskChannel );
        }

    	logger.info("Processed "+folderContents.size()+" compartments.");

    	logger.info("Look for output in "+jacsFolder);
    	
    }

    private int indexFromName( String fileName ) {
        if ( fileName.startsWith(COMPARTMENT_FILE_PREFIX) ) {
            return Integer.parseInt( fileName.substring( COMPARTMENT_FILE_PREFIX.length() ) ) + 1;
        }
        else {
            throw new IllegalArgumentException( "File name " + fileName + " not in expected format." );

        }
    }

    protected Entity populateChildren(Entity entity) throws ComputeException {
    	if (entity==null || EntityUtils.areLoaded(entity.getEntityData())) return entity;
		EntityUtils.replaceChildNodes(entity, entityBean.getChildEntities(entity.getId()));
		return entity;
    }

    protected Entity createCompartmentEntity(String entityTypeName, Integer index, CompartmentDescriptor compartmentDescriptor) throws Exception {
        String compartmentDescriptiveName = compartmentDescriptor.getCompartmentDescriptiveName();
        Entity compartmentEntity = new Entity();
        compartmentEntity.setOwnerKey(ownerKey);
        compartmentEntity.setEntityTypeName(entityTypeName);
        compartmentEntity.setName(compartmentDescriptiveName);
        compartmentEntity.setValueByAttributeName(
                EntityConstants.ATTRIBUTE_COLOR,
                StringUtils.encodeToHex(compartmentDescriptor.getColors(), logger)
        );
        compartmentEntity.setValueByAttributeName(EntityConstants.ATTRIBUTE_NUMBER, index.toString());
        compartmentEntity = saveStampedEntity(compartmentEntity);
        logger.info("Saved compartment entity as " + compartmentEntity.getId());
        return compartmentEntity;
    }

    protected Entity createCompartmentSetEntity(String entityTypeName, String compartmentSetName, String opticalResolution, String pixelResolution) throws Exception {
        Entity compartmentSetEntity = new Entity();
        compartmentSetEntity.setOwnerKey(ownerKey);
        compartmentSetEntity.setEntityTypeName(entityTypeName);
        compartmentSetEntity.setName(compartmentSetName);
        compartmentSetEntity.setValueByAttributeName(EntityConstants.ATTRIBUTE_ALIGNMENT_SPACE, DEFAULT_ALIGNMENT_SPACE);
        compartmentSetEntity.setValueByAttributeName(EntityConstants.ATTRIBUTE_OPTICAL_RESOLUTION, opticalResolution);
        compartmentSetEntity.setValueByAttributeName(EntityConstants.ATTRIBUTE_PIXEL_RESOLUTION, pixelResolution);
        compartmentSetEntity = saveStampedEntity(compartmentSetEntity);
        logger.info("Saved compartment set entity as " + compartmentSetEntity.getId());
        return compartmentSetEntity;
    }

    protected void createAndAddMaskChanEntities( Entity compartment, MaskChannel maskChannel ) throws Exception {

        // create3dImage takes the owner key and sets it on its nascent entity.
        Entity mask3d = helper.create3dImage( maskChannel.maskFile.getAbsolutePath() );
        helper.setImage( compartment, EntityConstants.ATTRIBUTE_MASK_IMAGE, mask3d );
        //helper.addToParent(compartment, mask3d, compartment.getMaxOrderIndex()+1, EntityConstants.ATTRIBUTE_MASK_IMAGE);

        Entity channel3d = helper.create3dImage( maskChannel.channelFile.getAbsolutePath() );
        helper.setImage( compartment, EntityConstants.ATTRIBUTE_CHAN_IMAGE, channel3d );
        //helper.addToParent(compartment, channel3d, compartment.getMaxOrderIndex()+1, EntityConstants.ATTRIBUTE_CHAN_IMAGE);
    }


    private Entity saveStampedEntity(Entity entity) throws ComputeException {
        logger.info("At save-stamped-entity time, owner key is " + ownerKey);
        entity.setCreationDate(createDate);
        entity.setUpdatedDate(createDate);
        entity = entityBean.saveOrUpdateEntity(entity);
        return entity;
    }

    protected Entity createOrVerifyRootEntity(String topLevelFolderName, String ownerKey, Date createDate, boolean createIfNecessary, boolean loadTree) throws Exception {
        Set<Entity> topLevelFolders = entityBean.getEntitiesByName(topLevelFolderName);
        Entity topLevelFolder = null;
        if (topLevelFolders != null) {
            // Only accept the current user's top level folder
            for (Entity entity : topLevelFolders) {
                if (entity.getOwnerKey().equals(ownerKey)
                        && entity.getEntityTypeName().equals(EntityConstants.TYPE_FOLDER)
                        && entity.getValueByAttributeName(EntityConstants.ATTRIBUTE_COMMON_ROOT) != null) {
                    // This is the folder we want, now load the entire folder hierarchy
                    if (loadTree) {
                        topLevelFolder = entityBean.getEntityTree(entity.getId());
                    } else {
                        topLevelFolder = entity;
                    }
                    logger.info("Found existing topLevelFolder common root, compartmentShortName=" + topLevelFolder.getName());
                    break;
                }
            }
        }

        if (topLevelFolder == null && createIfNecessary) {
            logger.info("Creating new topLevelFolder with compartmentShortName=" + topLevelFolderName);
            topLevelFolder = new Entity();
            topLevelFolder.setOwnerKey( ownerKey );
            topLevelFolder.setCreationDate(createDate);
            topLevelFolder.setUpdatedDate(createDate);
            topLevelFolder.setOwnerKey(ownerKey);
            topLevelFolder.setName(topLevelFolderName);
            topLevelFolder.setEntityTypeName(EntityConstants.TYPE_FOLDER);
            EntityUtils.addAttributeAsTag(topLevelFolder, EntityConstants.ATTRIBUTE_COMMON_ROOT);
            topLevelFolder = entityBean.saveOrUpdateEntity(topLevelFolder);
            logger.info("Saved top level folder as " + topLevelFolder.getId());
        }
        logger.info("At top-level-folder time, owner key is " + ownerKey);

        return topLevelFolder;
    }

    private Map<String, MaskChannel> readInputFolderContents( String inputFolderStr ) throws Exception {
        File dirFile = new File( inputFolderStr );
        if ( ! dirFile.canRead() ) {
            throw new Exception( "Cannot read file " + inputFolderStr );
        }
        else if ( ! dirFile.isDirectory() ) {
            throw new Exception( "Input file is not a directory: " + inputFolderStr );
        }
        else {
            File[] maskAndChanFiles = dirFile.listFiles( new FileFilter() {
                public boolean accept( File fileOnList ) {
                    String name = fileOnList.getName();
                    return name.endsWith(".chan") || name.endsWith(".mask");
                }
            });

            if ( maskAndChanFiles == null  ||  maskAndChanFiles.length == 0 ) {
                throw new Exception( "No files found in " + inputFolderStr );
            }
            else {
                Map<String, MaskChannel> nameToFileList = new TreeMap<String, MaskChannel>();
                for ( File file: maskAndChanFiles ) {
                    String justFileName = file.getName().substring(0, file.getName().lastIndexOf("."));
                    MaskChannel maskChannel = nameToFileList.get( justFileName );
                    if ( maskChannel == null ) {
                        maskChannel = new MaskChannel();
                    }
                    if ( file.getName().endsWith( ".mask" ) ) {
                        maskChannel.maskFile = file;
                    }
                    else {
                        maskChannel.channelFile = file;
                    }
                    nameToFileList.put( justFileName, maskChannel );
                }

                return nameToFileList;
            }
        }
    }

    private Map<Integer,CompartmentDescriptor> parseCompartmentsDescriptorFile() throws Exception {
        Map<Integer, CompartmentDescriptor> indexVsCompartment = new TreeMap<Integer, CompartmentDescriptor>();
        BufferedReader rdr = new BufferedReader( new FileReader( COMPARTMENT_NAMES_FILE  ) );
        String nextLine;

        // Prototype input line:
        // 56 WED_L "Description" ( 53 45 215 )
        while ( null != ( nextLine = rdr.readLine() ) ) {
            String[] fields = nextLine.trim().split( " " );
            if ( fields.length >= 8 ) {
                Integer labelNum = Integer.parseInt( fields[ 0 ] );
                String compartmentName = fields[ 1 ];
                int openParenPos = nextLine.lastIndexOf("(");
                int closeParenPos = nextLine.lastIndexOf(")");
                String colorNums = nextLine.substring( openParenPos + 1, closeParenPos );

                String[] colorNumArr = colorNums.trim().split(" ");
                int[] rgb = new int[] {
                        Integer.parseInt( colorNumArr[ 0 ] ),
                        Integer.parseInt( colorNumArr[ 1 ] ),
                        Integer.parseInt( colorNumArr[ 2 ] ),
                };

                CompartmentDescriptor descriptor = new CompartmentDescriptor( compartmentName, labelNum, rgb, colorNums );
                indexVsCompartment.put(labelNum, descriptor);
            }
        }
        rdr.close();
        return indexVsCompartment;
    }

    private static class MaskChannel {
        public File maskFile;
        public File channelFile;
    }

    private static class CompartmentDescriptor implements Comparable<CompartmentDescriptor> {
        private String compartmentShortName;
        private String compartmentDescriptiveName;
        private Integer compartmentNum;
        private String colors;
        private int[] rgb;

        public CompartmentDescriptor( String name, Integer compartmentNum, int[] rgb, String colors ) {
            this.compartmentShortName = name;
            this.compartmentNum = compartmentNum;
            this.rgb = rgb;
            this.colors = colors;
            this.compartmentDescriptiveName =
                    PatternAnnotationDataManager.getCompartmentDescription( compartmentShortName )
                            + " (" + compartmentShortName + ")";
        }

        public String getCompartmentShortName() { return compartmentShortName; }

        public Integer getCompartmentNum() {
            return compartmentNum;
        }

        public String getColors() {
            return colors;
        }

        public int[] getRgb() {
            return rgb;
        }

        @Override
        public boolean equals( Object o ) {
            boolean rtnVal = false;
            if ( o != null  &&  o instanceof CompartmentDescriptor ) {
                CompartmentDescriptor otherDescriptor = (CompartmentDescriptor)o;
                if ( otherDescriptor.getCompartmentNum() == compartmentNum ) {
                    rtnVal = true;
                }
            }
            return rtnVal;
        }

        @Override
        public int hashCode() {
            return compartmentNum;
        }

        public String getCompartmentDescriptiveName() {
            return compartmentDescriptiveName;
        }

        @Override
        public int compareTo(CompartmentDescriptor o) {
            return compartmentDescriptiveName.compareTo( o.getCompartmentDescriptiveName() );
        }
    }
}
