package org.janelia.it.jacs.compute.service.fly;

import org.janelia.it.jacs.compute.api.ComputeException;
import org.janelia.it.jacs.compute.service.entity.AbstractEntityService;
import org.janelia.it.jacs.compute.service.fileDiscovery.FileDiscoveryHelper;
import org.janelia.it.jacs.model.entity.Entity;
import org.janelia.it.jacs.model.entity.EntityConstants;
import org.janelia.it.jacs.model.entity.EntityType;
import org.janelia.it.jacs.shared.annotation.PatternAnnotationDataManager;
import org.janelia.it.jacs.shared.utils.EntityUtils;

import java.io.*;
import java.util.*;

/**
 * This service loads screen scores from *.arnimScoreOutput files generated by Sean's Perl scripts, and organizes the 
 * screen samples into intensity and distribution score folders. 
 *
 * @author <a href="mailto:rokickik@janelia.hhmi.org">Konrad Rokicki</a>
 */
public class MaskChanCompartmentLoadingService extends AbstractEntityService {
	
	private static final boolean DEBUG = false;
	
    private static final String FOLDER_PARAM = "TOP_LEVEL_FOLDER_NAME";
    private static final String INPATH_PARAM = "MASK_CHAN_PATH";

    private static final String COMPARTMENT_NAMES_FILE = "/groups/scicomp/jacsData/MaskResources/Compartment/maskNameIndex.txt";
    private static final String COMPARTMENT_FILE_PREFIX = "compartment_";

    private static final String DEFAULT_ALIGNMENT_SPACE = "Unified 20x Alignment Space";
    private static final String DEFAULT_OPTICAL_RESOLUTION = "0.62x0.62x0.62";
    private static final String DEFAULT_PIXEL_RESOLUTION = "1024x512x218";

    protected Date createDate;
	protected FileDiscoveryHelper helper;
    
    protected EntityType folderType;
    
    protected SortedSet<String> loaded = new TreeSet<String>();

    /**
     * See the MaskChanCompartmentsLoadingPipeline.process:
     *
     * 	    <operation name="Import Variables" processor="org.janelia.it.jacs.compute.service.common.InitVariablesFromTaskService">
     *      <input name="TASK_PARAMETER_1" value="mask chan file path"/>
     *      <input name="PROCESS_VARIABLE_1" value="MASK_CHAN_PATH"/>
     *      <input name="TASK_PARAMETER_2" value="top level folder name"/>
     *      <input name="PROCESS_VARIABLE_2" value="TOP_LEVEL_FOLDER_NAME"/>
     *      <output name="MASK_CHAN_PATH"/>
     *      <output name="TOP_LEVEL_FOLDER_NAME"/>
     *      </operation>
     *
     * @throws Exception
     */
    @Override
    public void execute() throws Exception {

        createDate = new Date();
        helper = new FileDiscoveryHelper(entityBean, computeBean, ownerKey, logger);
        folderType = entityBean.getEntityTypeByName(EntityConstants.TYPE_FOLDER);
        
        String inputFSFolder = (String)processData.getItem(INPATH_PARAM);

    	if (inputFSFolder == null) {
    		throw new IllegalArgumentException(INPATH_PARAM + " may not be null");
    	}

        String jacsFolder = (String)processData.getItem(FOLDER_PARAM);
    	if (jacsFolder == null) {
    		throw new IllegalArgumentException(FOLDER_PARAM + " may not be null");
    	}
    	
        // Check input path: has files of correct type?  If so, get them into a convenient form.
        Map<String,MaskChannel> folderContents = readInputFolderContents(inputFSFolder);

    	// Create top level folder (or obtained the named empty one).
    	Entity topLevelFolder = populateChildren(createOrVerifyRootEntity(jacsFolder, ownerKey, createDate, true, false));
    	
    	if (!topLevelFolder.getChildren().isEmpty()) {
    		throw new IllegalStateException(
                    "Cannot reuse existing top level with name " + jacsFolder + " folder, id="+topLevelFolder
            );
    	}

        // Compartments belong to a compartment set that has characteristics of all contents.
        EntityType compartmentSetEntityType = entityBean.getEntityTypeByName( EntityConstants.TYPE_COMPARTMENT_SET );
        String compartmentSetName = "Compartment Set " + DEFAULT_ALIGNMENT_SPACE + " " + DEFAULT_OPTICAL_RESOLUTION + " " + DEFAULT_PIXEL_RESOLUTION;
        Entity compartmentSetEntity = createCompartmentSetEntity( compartmentSetEntityType, compartmentSetName );

        // Add this set as an entity-child of the folder.
        helper.addToParent( topLevelFolder, compartmentSetEntity, topLevelFolder.getMaxOrderIndex()+1, EntityConstants.ATTRIBUTE_ENTITY );

        // Get the mask/name index contents.
        Map<String,Integer> maskNameIndex = digestMaskNameIndex();
        // Invert the map.
        Map<Integer,String> indexToName = new HashMap<Integer,String>();
        for ( String key: maskNameIndex.keySet() ) {
            indexToName.put( maskNameIndex.get( key ), key );
        }

        // Process each Mask/Channel combination.  Indexes start at 0, so bump by one.
        EntityType compartmentEntityType = entityBean.getEntityTypeByName( EntityConstants.TYPE_COMPARTMENT );
    	for ( String key: folderContents.keySet() ) {
            logger.info("Saving compartment " + key);
            MaskChannel maskChannel = folderContents.get( key );

            // Create the compartment and add it to the set.
            int index = indexFromName( key );
            Entity compartment = createCompartmentEntity( compartmentEntityType, index, indexToName.get( index ) );
            helper.addToParent(compartmentSetEntity, compartment, compartmentSetEntity.getMaxOrderIndex()+1, EntityConstants.ATTRIBUTE_ENTITY);

            // Create the mask and channel and add them to the compartment.
            createAndAddMaskChanEntities( compartment, maskChannel );
        }

    	logger.info("Processed "+folderContents.size()+" compartments.");

    	logger.info("Look for output in "+jacsFolder);
    	
    }

    private int indexFromName( String fileName ) {
        if ( fileName.startsWith(COMPARTMENT_FILE_PREFIX) ) {
            return Integer.parseInt( fileName.substring( COMPARTMENT_FILE_PREFIX.length() ) ) + 1;
        }
        else {
            throw new IllegalArgumentException( "File name " + fileName + " not in expected format." );

        }
    }

    protected Entity populateChildren(Entity entity) throws ComputeException {
    	if (entity==null || EntityUtils.areLoaded(entity.getEntityData())) return entity;
		EntityUtils.replaceChildNodes(entity, entityBean.getChildEntities(entity.getId()));
		return entity;
    }

    protected Entity createCompartmentEntity(EntityType entityType, Integer index, String compartmentShortName) throws Exception {
        Entity compartmentEntity = new Entity();
        compartmentEntity.setOwnerKey(ownerKey);
        compartmentEntity.setEntityType(entityType);
        compartmentEntity.setName(compartmentShortName + " Compartment");
        compartmentEntity.setValueByAttributeName(EntityConstants.ATTRIBUTE_NUMBER, index.toString());
        String compartmentDescriptiveName = PatternAnnotationDataManager.getCompartmentDescription( compartmentShortName );
        compartmentEntity.setValueByAttributeName(EntityConstants.ATTRIBUTE_NAME, compartmentDescriptiveName);
        compartmentEntity = saveStampedEntity(compartmentEntity);
        logger.info("Saved compartment entity as " + compartmentEntity.getId());
        return compartmentEntity;
    }

    protected Entity createCompartmentSetEntity(EntityType entityType, String compartmentSetName) throws Exception {
        Entity compartmentSetEntity = new Entity();
        compartmentSetEntity.setOwnerKey(ownerKey);
        compartmentSetEntity.setEntityType(entityType);
        compartmentSetEntity.setName(compartmentSetName);
        compartmentSetEntity.setValueByAttributeName(EntityConstants.ATTRIBUTE_ALIGNMENT_SPACE, DEFAULT_ALIGNMENT_SPACE);
        compartmentSetEntity.setValueByAttributeName(EntityConstants.ATTRIBUTE_OPTICAL_RESOLUTION, DEFAULT_OPTICAL_RESOLUTION);
        compartmentSetEntity.setValueByAttributeName(EntityConstants.ATTRIBUTE_PIXEL_RESOLUTION, DEFAULT_PIXEL_RESOLUTION);
        compartmentSetEntity = saveStampedEntity(compartmentSetEntity);
        logger.info("Saved compartment set entity as " + compartmentSetEntity.getId());
        return compartmentSetEntity;
    }

    protected void createAndAddMaskChanEntities( Entity compartment, MaskChannel maskChannel ) throws Exception {

        Entity mask3d = helper.create3dImage( maskChannel.maskFile.getAbsolutePath() );
        helper.addToParent(compartment, mask3d, compartment.getMaxOrderIndex()+1, EntityConstants.ATTRIBUTE_MASK_IMAGE);

        Entity channel3d = helper.create3dImage( maskChannel.channelFile.getAbsolutePath() );
        helper.addToParent(compartment, channel3d, compartment.getMaxOrderIndex()+1, EntityConstants.ATTRIBUTE_CHAN_IMAGE);
    }

    private Entity saveStampedEntity(Entity entity) throws ComputeException {
        logger.info("At save-stamped-entity time, owner key is " + ownerKey);
        entity.setCreationDate(createDate);
        entity.setUpdatedDate(createDate);
        entity = entityBean.saveOrUpdateEntity(entity);
        return entity;
    }

    protected Entity createOrVerifyRootEntity(String topLevelFolderName, String ownerKey, Date createDate, boolean createIfNecessary, boolean loadTree) throws Exception {
        Set<Entity> topLevelFolders = entityBean.getEntitiesByName(topLevelFolderName);
        Entity topLevelFolder = null;
        if (topLevelFolders != null) {
            // Only accept the current user's top level folder
            for (Entity entity : topLevelFolders) {
                if (entity.getOwnerKey().equals(ownerKey)
                        && entity.getEntityType().getName().equals(folderType.getName())
                        && entity.getAttributeByName(EntityConstants.ATTRIBUTE_COMMON_ROOT) != null) {
                    // This is the folder we want, now load the entire folder hierarchy
                    if (loadTree) {
                        topLevelFolder = entityBean.getEntityTree(entity.getId());
                    } else {
                        topLevelFolder = entity;
                    }
                    logger.info("Found existing topLevelFolder common root, name=" + topLevelFolder.getName());
                    break;
                }
            }
        }

        if (topLevelFolder == null && createIfNecessary) {
            logger.info("Creating new topLevelFolder with name=" + topLevelFolderName);
            topLevelFolder = new Entity();
            topLevelFolder.setCreationDate(createDate);
            topLevelFolder.setUpdatedDate(createDate);
            topLevelFolder.setOwnerKey(ownerKey);
            topLevelFolder.setName(topLevelFolderName);
            topLevelFolder.setEntityType(folderType);
            EntityUtils.addAttributeAsTag(topLevelFolder, EntityConstants.ATTRIBUTE_COMMON_ROOT);
            topLevelFolder = entityBean.saveOrUpdateEntity(topLevelFolder);
            logger.info("Saved top level folder as " + topLevelFolder.getId());
        }
        logger.info("At top-level-folder time, owner key is " + ownerKey);

        return topLevelFolder;
    }

    private Map<String, MaskChannel> readInputFolderContents( String inputFolderStr ) throws Exception {
        File dirFile = new File( inputFolderStr );
        if ( ! dirFile.canRead() ) {
            throw new Exception( "Cannot read file " + inputFolderStr );
        }
        else if ( ! dirFile.isDirectory() ) {
            throw new Exception( "Input file is not a directory: " + inputFolderStr );
        }
        else {
            File[] maskAndChanFiles = dirFile.listFiles( new FileFilter() {
                public boolean accept( File fileOnList ) {
                    String name = fileOnList.getName();
                    return name.endsWith(".chan") || name.endsWith(".mask");
                }
            });

            if ( maskAndChanFiles == null  ||  maskAndChanFiles.length == 0 ) {
                throw new Exception( "No files found in " + inputFolderStr );
            }
            else {
                Map<String, MaskChannel> nameToFileList = new TreeMap<String, MaskChannel>();
                for ( File file: maskAndChanFiles ) {
                    String justFileName = file.getName().substring(0, file.getName().lastIndexOf("."));
                    MaskChannel maskChannel = nameToFileList.get( justFileName );
                    if ( maskChannel == null ) {
                        maskChannel = new MaskChannel();
                    }
                    if ( file.getName().endsWith( ".mask" ) ) {
                        maskChannel.maskFile = file;
                    }
                    else {
                        maskChannel.channelFile = file;
                    }
                    nameToFileList.put( justFileName, maskChannel );
                }

                return nameToFileList;
            }
        }
    }

    private Map<String,Integer> digestMaskNameIndex() throws Exception {
        Map<String, Integer> nameVsNum = new TreeMap<String, Integer>();
        BufferedReader rdr = new BufferedReader( new FileReader( COMPARTMENT_NAMES_FILE  ) );
        String nextLine = null;

        // Prototype input line:
        // 56 WED_L "Description" ( 53 45 215 )
        while ( null != ( nextLine = rdr.readLine() ) ) {
            String[] fields = nextLine.trim().split( " " );
            if ( fields.length >= 8 ) {
                Integer labelNum = Integer.parseInt( fields[ 0 ] );
                String compartmentName = fields[ 1 ];
                nameVsNum.put( compartmentName, labelNum );
            }
        }
        rdr.close();
        return nameVsNum;
    }

    private static class MaskChannel {
        public File maskFile;
        public File channelFile;
    }
}
